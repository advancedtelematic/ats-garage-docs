= Automotive Grade Linux
:page-layout: page
:page-categories: [hidden]
:page-date: 2017-05-16 15:54:29
:page-order: 2
:icons: font
:toc: macro

ATS Garage lets you easily manage OTA updates to embedded devices running custom-built Yocto images. It works great with Automotive Grade Linux, so building an AGL image is one easy way to get started. If your planned project is automotive, AGL is a great choice to start out with.

toc::[]

== 0. Prerequisites

You'll need some AGL-supported hardware, and a build machine with the following:

* A x86-64 Linux distro link:http://www.yoctoproject.org/docs/2.2/ref-manual/ref-manual.html#detailed-supported-distros[supported by the Yocto project] with the link:http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#required-packages-for-the-host-development-system[required packages] installed. (On a Debian-based system, you should be able to install all the required packages with `sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm repo`.)
** Many/most distros that aren't on the officially supported list will still work just fine, but YMMV.
** Although the Yocto project as a whole does support architectures other than x86-64 for the build machine, one of the layers we'll be using only supports x86-64.
** You *can* run this all inside a VM, but a Yocto build is a pretty resource-intensive process, so generally we don't recommend it. If you do, make sure there's plenty of ram and disk space available to the VM.
* 100GB of free disk space
* link:https://android.googlesource.com/tools/repo/[repo]
** link:https://source.android.com/source/downloading#installing-repo[Download the latest version] directly from Google, or
** install it from your distro's packages if available (`apt-get install repo`)

== 1. Provisioning credentials

**Device Provisioning** is the process of attaching individual credentials and certificates to a device. ATS Garage automates this process for you, allowing you to use the same unmodified disk image on many different devices and registering each one with ATS Garage the first time it boots.

Go to the https://app.atsgarage.com/#/profile/access-keys[**Provisioning Keys**, window="_blank"] tab of your profile.

image::../images/provisioning-key-menu.png[]

Create a new key, select its period of validity, and then download it.

image::../images/provisioning-screen.png[]

It comes as a zip file containing a provisioning key and credentials for your build system to publish images. You don't need to unzip it; just save it somewhere. You'll need it when you set up your Yocto build.

== 2. Create your AGL Yocto build environment

=== 2.1 Get AGL master manifest

First, clone a manifest file for AGL master:

----
mkdir myproject
cd myproject
repo init -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo
repo sync
----

This will download the basic Yocto layers you need.

.What is this actually doing?
****
Yocto is a set of tools, templates and methods for building Linux systems from scratch. Automotive Grade Linux is a complete Linux distribution designed for in-car systems. It includes base system layers from Poky and OpenEmbedded, board support layers for popular automotive platforms, and quite a lot more.

All of these layers are assembled into a built Linux system by Bitbake, the build tool of the Yocto Project, based on the instructions in the recipes inside the layers.
****

=== 2.2 Check out latest meta-updater layer

AGL's version of meta-updater is usually a few revisions behind the latest one. ATS Garage is generally tested against the latest github revision of meta-updater, so we'll check out that one.

----
cd meta-updater
git checkout morty
cd ..
----

=== 2.3 Run environment setup script

Now you can run the following script to get the environment set up:

----
source meta-agl/scripts/aglsetup.sh -m <target-architecture> agl-demo agl-appfw-smack agl-sota <1>
----
<1> Where `target-architecture` one of: `raspberrypi2`, `raspberrypi3`, or `qemux86-64`.

== 3. Customize your build

There are two things that are mandatory to change: you need to select a client to installfootnote:[ATS develops two open source clients compatible with ATS Garage, one written in Rust called rvi-sota-client, and one written in C++ called aktualizr. We'll use the Rust client for now; it gets the newest features first, and currently is the only one of the two that fully supports Uptane updates.], and add the provisioning credentials bundle you downloaded earlier. Add the following two lines to your local.conf:

----
SOTA_PACKED_CREDENTIALS = "/path/to/your/credentials.zip"
SOTA_CLIENT = "rvi-sota-client"
----

WARNING: AGL's environment setup script, _unlike_ most other Yocto distributions, overwrites local.conf each time it is run. Anything you need to add, you'll have to add again after each time you run the environment setup.

=== Optional configuration keys

* *Set image name*

When you build a filesystem image, it gets automatically uploaded to ATS Garage. By default, the image will be named `{MACHINE}-ota`, and you'll see the various versions of the image under that name. You can also choose to set your own name as follows:

----
OSTREE_BRANCHNAME = "my-super-great-project"
----

* *Persistent Yocto shared state cache and download directory*

Yocto caches its build artefacts to speed up future builds. By default, these are stored under the build directory of the current project. However, if you're planning to build several different projects that have some shared base files, you might want them to share their cache directories, both to save space and speed up your builds. You can do that as follows:

----
SSTATE_DIR = "/path/to/your/shared-sstate"
DL_DIR = "/path/to/your/shared-download"
----

* *Remote Yocto shared state cache*

Yocto also supports the use of remote caches. ATS provides one; you can configure your build to use it as follows:

----
SSTATE_MIRRORS ?= "file://.* https://bitbake-cache.atsgarage.com/PATH;downloadfilename=PATH"
----

This will save you some compilation time, as bitbake downloads some intermediate build artefacts instead of building them itself.

* *Add extra packages*

There are quite a lot of packages available to install that aren't installed by default. You can add extra packages to your image with *IMAGE_INSTALL_append*; for example, this will install vim:

----
IMAGE_INSTALL_append = " vim " <1>
----
<1> Note the spaces before and after the package name. This option dumbly appends a string to an install list, so we wrap it in spaces to make sure we don't alter the list in unexpected ways.

You can get a list of all the available packages in the layers you have configured with `bitbake-layers show-recipes`

== 4. Bitbake

Now you're ready to build an image.

----
bitbake agl-demo-platform <1>
----
<1> Or whatever other target you wish.

image::https://imgs.xkcd.com/comics/compiling.png[float="left",align="center"]

This step will take a while. The first time you build, it will likely be on the scale of several hours.

== 5. Put the built image on your device's boot media

The build process creates disk images as an artefact. The exact image you'll need will vary depending on the architecture you're building for, but it will be located in the `/tmp/deploy/images` directory under your build directory. We recommend using https://etcher.io/[Etcher, window="_blank"] or https://etcher.io/cli/[Etcher CLI, window="_blank"] to write the image.

TIP: You can also write the image using `dd`, but since the wrong kind of typo in a dd command is so dangerous, we don't recommend it.

You'll probably also want to resize the main partition to fill all of the space on the boot media:

----
sudo parted -s /dev/sdX resizepart 2 '100%' <1>
sudo resize2fs /dev/sdX2 <1>
----
<1> Where /dev/sdX is the device you wrote the image to.

You should now be able to boot your device and have it show up in your ATS Garage account.

[discrete]
== link:../quickstarts/pushing-updates.html[Next: Pushing your first update >>]
