= Automotive Grade Linux
:page-layout: page
:page-categories: [quickstarts]
:page-date: 2017-05-16 15:54:29
:page-order: 2
:icons: font
:toc: macro
:device: AGL-supported board
:machine: <machine-name>
:image: agl-demo-platform

ATS Garage lets you easily manage OTA updates to embedded devices running custom-built Yocto images. It works great with Automotive Grade Linux, so building an AGL image is one easy way to get started. If your planned project is automotive, AGL is a great choice to start out with.

toc::[]

// Most of the content here is the same as the Raspberry Pi instructions, so we re-use the chunks we can.

include::../_pages/quickstarts/raspberry-pi.adoc[tags=prereqs;provisioning]

== 2. Create your AGL Yocto build environment

=== 2.1 Get AGL master manifest

First, clone a manifest file for AGL master:

----
mkdir myproject
cd myproject
repo init -u https://gerrit.automotivelinux.org/gerrit/AGL/AGL-repo
repo sync
----

This will download the basic Yocto layers you need.

.What is this actually doing?
****
Yocto is a set of tools, templates and methods for building Linux systems from scratch. Automotive Grade Linux is a complete Linux distribution designed for in-car systems. It includes base system layers from Poky and OpenEmbedded, board support layers for popular automotive platforms, and quite a lot more.

All of these layers are assembled into a built Linux system by Bitbake, the build tool of the Yocto Project, based on the instructions in the recipes inside the layers.
****

=== 2.2 Check out latest meta-updater layer

AGL's version of meta-updater is usually a few revisions behind the latest one. ATS Garage is always tested against the latest github revision of on the *morty* branch of meta-updater, so we'll check out that one.

----
cd meta-updater
git checkout morty
cd ..
----

=== 2.3 Run environment setup script

Now you can run the following script to get the environment set up:

----
source meta-agl/scripts/aglsetup.sh -m <target-architecture> agl-demo agl-appfw-smack agl-sota <1>
----
<1> Where `target-architecture` is one of: `raspberrypi2`, `raspberrypi3`, or `qemux86-64`.

include::../_pages/quickstarts/raspberry-pi.adoc[tags=config;bitbake]

== 5. Put the built image on your device's boot media

The build process creates disk images as an artefact. The exact image you'll need will vary depending on the architecture you're building forfootnote:[For example, building the `agl-demo-platform` target for Raspberry Pi 3 creates an image at `/tmp/deploy/images/raspberrypi3/agl-demo-platform-raspberrypi3.rootfs.rpi-sdimg-ota`.], but it will be located in the `/tmp/deploy/images` directory under your build directory. We recommend using https://etcher.io/[Etcher, window="_blank"] or https://etcher.io/cli/[Etcher CLI, window="_blank"] to write the image.

TIP: You can also write the image using `dd`, but since the wrong kind of typo in a dd command is so dangerous, we don't recommend it.

You'll probably also want to resize the main partition to fill all of the space on the boot media:

----
sudo parted -s /dev/sdX resizepart 2 '100%' <1>
sudo resize2fs /dev/sdX2 <1>
----
<1> Where /dev/sdX is the device you wrote the image to.

You should now be able to boot your device and have it show up in your ATS Garage account.

[discrete]
== link:../quickstarts/pushing-updates.html[Next: Pushing your first update >>]
