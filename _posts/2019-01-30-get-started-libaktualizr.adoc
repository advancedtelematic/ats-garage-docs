= Get started
:page-layout: page
:page-categories: [using-libaktualizr]
:page-date: 2018-11-28 14:08:55
:page-order: 2
:icons: font

Aktualizr is a {cpp} application that implements client-side functionality for
HERE OTA Connect system based on the Uptane security framework<<anchor-1,[1]>>.
While it is possible to use Aktualizr as a standalone CLI application,
using it as a {cpp} library from a custom application provides user with
more flexibility and customization.

This guide focuses on integrating Aktualizr functionality into a
custom application, in other words it focuses on using libaktualizr.

== How to build libaktualizr

Aktualizr is an open-source software distributed
under the Mozilla Public License 2.0 and is located on github:
https://github.com/advancedtelematic/aktualizr

The project is intended to be build on a Linux system and compiler must support
C++11 version of the standard.
File README.adoc located in the project root directory contains
extended description on how to build it as well as the list of
build and run-time dependencies.
Please, refer to this list and install all the dependencies before
proceeding to the next step.

These are the steps needed to locally build a Release version of libaktualizr:
[source,bash]
$ git clone --recursive https://github.com/advancedtelematic/aktualizr.git
$ cd aktualizr
$ mkdir build
$ cd build
$ cmake ..
$ make

Note the `--recursive` flag in the `git clone` command, it is needed
to recursively clone all the *git submodule* repositories.

After the build is finished, the resulting library can be found as
`${PROJECT_ROOT}/build/src/libaktualizr/libaktualizr_static_lib.a`.

== Integrating libaktualizr into your application

=== Building libaktualizr in-tree
The easiest way to integrate with libaktualizr, is to add it as a subdirectory
to your cmake project. To do that you just need to clone the aktualizr into your
project directory:
[source,bash]
$ git clone --recursive https://github.com/advancedtelematic/aktualizr.git

and add it to your CMakeLists.txt:
[source,cmake]
add_subdirectory(aktualizr)

This will automatically add needed entries to `INCLUDE_DIRECTORIES` variable,
create `AKTUALIZR_EXTERNAL_LIBS` variable, which contains the list of external
libraries required for linking with libaktualizr, and will create
`aktualizr_static_lib` target. When building your application these libraries
should be added with
[source,cmake]
target_link_libraries(your-app aktualizr_static_lib ${AKTUALIZR_EXTERNAL_LIBS})

You also might need to add the following line if you are using boost libraries:
[source,cmake]
add_definitions(-DBOOST_LOG_DYN_LINK)

=== Building libaktualizr out-of-tree
If you don't want to make libaktualizr part of your cmake project, it's also
possible to build libaktualizr out-of-tree. In this case you will need
to specify the required libraries and includes for your application manually:
[source,cmake]
----
target_link_libraries(your-app ${AKTUALIZR_PROJECT_DIR}/build/src/libaktualizr/libaktualizr_static_lib.a)
target_link_libraries(your-app pthread)
target_link_libraries(your-app archive)
target_link_libraries(your-app boost_atomic)
target_link_libraries(your-app boost_chrono)
target_link_libraries(your-app boost_date_time)
target_link_libraries(your-app boost_filesystem)
target_link_libraries(your-app boost_log)
target_link_libraries(your-app boost_log_setup)
target_link_libraries(your-app boost_program_options)
target_link_libraries(your-app boost_regex)
target_link_libraries(your-app boost_system)
target_link_libraries(your-app boost_thread)
target_link_libraries(your-app crypto)
target_link_libraries(your-app curl)
target_link_libraries(your-app sodium)
target_link_libraries(your-app sqlite3)
target_link_libraries(your-app ssl)

target_include_directories(your-app PRIVATE ${AKTUALIZR_PROJECT_DIR}/src/libaktualizr)
target_include_directories(your-app PRIVATE ${AKTUALIZR_PROJECT_DIR}/third_party/jsoncpp)

add_definitions(-DBOOST_LOG_DYN_LINK)
----
=== Non-cmake builds
If you are using a build system other than cmake, you will be building
libaktualizr out-of-tree. Please refer to your system's documentation on how to
specify additional libraries and include directories for the target application.

== How to use libaktualizr API

Libaktualizr provides a C++ API for fetching information about available updates
and currently running OTA campaigns, downloading and installing the updates,
reporting the installation results, and so on.

The main library header is `src/libaktualizr/primary/aktualizr.h` and it also
includes few other libaktualizr headers. To use the API you should add
`src/libaktualizr` directory to your include path
and add `#include "primary/aktualizr.h"` to your source file.

Most of the API calls, unless specified otherwise, are asynchronous and return
`std::future` that will contain corresponding result type. Result types are
defined in the `src/libaktualizr/primary/results.h` header.
Asynchronous commands are posted to the command queue and executed
in sequential order in a separate thread. If the execution was paused, newly
issued commands will accumulate in the command queue and it's up to the caller
to ensure that the queue does not get overloaded with unnecessary command
duplicates.

In case of failure to perform an action or some other kind of an error an
exception will be thrown. For asynchronous calls the exception will be stored
in the shared state associated with std::future. All exceptions are subclassed
from AktualizrException class.

There is a sample application that shows how libaktualizr API can be used.
The application is located in `src/hmi_stub`.

=== API Description

==== General management, configuration and control flow
[source,cpp]
Aktualizr::Aktualizr(boost::filesystem::path config)

Constructs an Aktualizr instance based on the provided config.
A config should at least contain information about provisioning credentials (see
`docs/automatic-provisioning.adoc`, `docs/implicit-provisioning.adoc` or
`hsm-provisioning.adoc` depending on the used provisioning type),
and about the local storage which will be used to store updates and metadata.
For description of all configuration options, please, refer to the
`docs/configuration.adoc` document and to the `config` folder for configuration
examples.

[source,cpp]
void Aktualizr::AddSecondary(const std::shared_ptr<Uptane::SecondaryInterface> &secondary)

Add new secondary to aktualizr. Must be called before Initialize.

[source,cpp]
void Aktualizr::Initialize()

Initialize aktualizr. Any secondaries should be added before making this
call. This will provision with the server if required. This must be called
before using any other aktualizr functions except AddSecondary.

[source,cpp]
boost::signals2::connection Aktualizr::SetSignalHandler(std::function<void(shared_ptr<event::BaseEvent>)> &handler)

Set a callback to receive event notifications.
Returns a signal connection object, which can be disconnected if desired.
The events are defined in the `src/libaktualizr/primary/events.h` header.

[source,cpp]
void Aktualizr::Pause()

Requests the currently running command to pause and freezes the command queue.
All commands that were scheduled after the currently executed command will wait
in the command queue until Resume() is issued.
Commands that are issued after Pause() will be put on a command queue,
but not executed until Resume() is called.

The Pause() function returns immediately, while pausing the running command
still may be in progress.

The function has no effect in case execution was already paused.

[source,cpp]
void Aktualizr::Resume()

Resumes the execution of a previously paused command and all subsequent commands
in the command queue.
Returns immediately. The function has no effect if the execution was not paused.

[source,cpp]
void Aktualizr::Abort()

Requests the currently running command to abort and flushes the command queue.
The Abort() function will block until the command queue is empty and no command
is in executed state.

Can also be called on a previously paused instance, but doesn't change
it's paused state.
If a paused command was aborted, next time it will start the execution
from the place it was paused.

[source,cpp]
Aktualizr::~Aktualizr(Config &config)

Calls Abort() and destroys the aktualizr object.

==== Campaign management commands
[source,cpp]
std::future<result::CampaignCheck> Aktualizr::CampaignCheck()

Check for campaigns.
Campaigns are a concept outside of Uptane, and allow for user approval of
updates before the contents of the update are known.

[source,cpp]
std::future<void> Aktualizr::CampaignAccept(const std::string &campaign_id)

Accept a campaign for the current device.
Campaigns are a concept outside of Uptane, and allow for user approval of
updates before the contents of the update are known.

==== Update management commands
[source,cpp]
std::future<void> Aktualizr::SendDeviceData()

Sends local device data to the server.
This includes network status, installed packages, hardware etc.

[source,cpp]
std::future<result::UpdateCheck> Aktualizr::CheckUpdates()

Fetch Uptane metadata and check for updates.
This collects a client manifest, PUTs it to the director, updates the
Uptane metadata (including root and targets), and then checks the metadata
for target updates.

[source,cpp]
std::future<result::Download> Aktualizr::Download(const std::vector<Uptane::Target> &updates)

Download targets specified in the input vector that were previously
returned by CheckUpdates.

[source,cpp]
std::future<result::Install> Aktualizr::Install(const std::vector<Uptane::Target> &updates)

Install previously downloaded targets.

[source,cpp]
std::ifstream Aktualizr::GetStoredTarget(const Uptane::Target &target)

==== Miscellaneous commands
[source,cpp]
void Aktualizr::UptaneCycle()

Synchronously run an uptane cycle: check for updates, download any new
targets, install them, and send a manifest back to the server.

[source,cpp]
std::future<void> Aktualizr::RunForever()

Asynchronously run aktualizr indefinitely until Shutdown is called.

== References
[[anchor-1]]
[1] https://docs.ota.here.com/concepts/ats-garage-security-with-uptane.html